# Message Routing
メッセージの処理をスケールアップ・スケールアウトする際に複数のインスタンスにメッセージを分配するために使用する。  
Akkaでは`パフォーマンスやスケーリングをサポートする` ための組み込みルーターが用意されており、それを使用することでメッセージのルーティングを実現できる。  
ただし、 `メッセージ内容や状態` によってメッセージを振り分ける場合は `通常のアクターを実装する` 方が良い。

## EIPのルーターパターン
ルーターのパターンには下記の3種類がある。

* パフォーマンス  
  メッセージの処理を並行化して処理能力を向上する
* メッセージ内容  
  メッセージの内容に応じて転送先を変更する
* ルーターの状態  
  転送先の状態に応じて転送先を変更する
  
## Akka Router
Akkaの組み込みルーターはパフォーマンスやスケーリングの向上に適している。

* ルーターアクター  
  転送先にメッセージを送信する責務を持つアクター
* ルーティングロジック  
  どの転送さきにメッセージを送信するかを決定するロジック
* ルーティー  
  メッセージの転送先のアクター
  
また、Akkaで提供しているルーターには下記の二種類のルーターがある。

### Pool
プールルーターは `ルーター自体がルーティーを保持・管理する。`
ルーターがルーティーを管理してくれるため、利用者はあまり考えずにシンプルに実装ができる。
また組み込みルーターはラウンドロビンやランダム、ブロードキャストなどの複数の選択肢が存在する。

### Group
グループルーターは `ルーター自体がルーティーを保持・管理しない。`  
ルーティーの生成や監視・管理はシステムの別箇所で実装を行う必要がある。  
プールルーターでは設定できない詳細な制御や特別なライフサイクルを持つルーティーを管理する必要がある場合はグループルーターを使う。

## 内容ベースのルーティング
内容ベースのルーティングを行う場合は単にアクターを用いてメセージの内容によって転送先を決定する。

## 状態ベースのルーティング
ルーターの内部状態に応じてルーティング先を決定するルーター。  
通常のアクターを使用して `context.become()` を使ってルーティング戦略を切り替えるとシンプルに実装できる。

```scala
class SwitchRouter(onActor: ActorRef, offActor: ActorRef) extends Actor {
  def on: Recieve = {
    case msg: Msg => onActor ! msg
    // offに切り替え  
    case _: OffMsg => context.become(off)
  }
  
  def off: Recieve = {
    case msg: Msg => offActor ! msg
    // onに切り替え
    case _: OnMsg => context.become(on)
  }
  
  // デフォルトはoff
  override def receive = off 
}
```

ただし上の例だとアクターの起動時は必ず `off` になるので、再起動時などは注意すること。 63